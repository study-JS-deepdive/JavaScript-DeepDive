# 12장 함수

## 1. 함수란?

**함수 : 입력을 받아서 출력을 내보내는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 정의한 것.**

함수 생성 : **함수 정의**를 통해 생성함.

함수 호출 : 호출 시 **함수가 실행**되고 실행 **결과(반환값)을 반환**함.

![IMG_3636.jpeg](attachment:db46c1bc-8de3-4e04-96ce-4f01a6c47492:IMG_3636.jpeg)

---

## 2. 함수를 사용하는 이유

**코드의 재사용** : 동일한 작업을 반복적으로 수행 시 코드를 중복해서 작성하지 않고 재사용하는 것이 효율적임.

**유지보수의 편의성 &** **코드의 신뢰성 :** 코드의 중복을 억제하고 재사용성을 높이고 실수는 줄임.

**+) 코드 가독성의 중요성** : 함수의 역할을 파악할 수 있는 **적절한 함수 이름**은 코드의 가독성을 향상시킴.

---

## 3. 함수 리터럴

```jsx
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```

 - 함수를 생성할 수 있음.

 - function 키워드, 함수 이름, 매개변수 목록, 함수 몸체

 - 평가되어 값을 생성하며, 이 값은 객체임. = 즉, **함수는 객체다**.

 - 단, 일반 객체와는 다름.

<aside>

**함수와 일반 객체의 차이점**

 : 함수는 호출할 수 있음.

 : 함수 객체만의 고유한 프로퍼티를 가짐.

</aside>

---

## 4. 함수 정의

- 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 됨.
- 함수를 정의하는 방법은 4가지임.
    
    : 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수(ES6)
    

### 4-1. 함수 선언문

- 함수 리터럴과 형태가 동일함.
- 단, 함수 리터럴과 달리 **함수 선언문은 함수 이름을 생략할 수 없음**.
- 표현식이 아닌 문임.

```jsx
function add(x, y) {
  return x + y;
}
```

- **코드의 문맥에 따른 자바스크립트 엔진의 함수 해석**
    
    자바스크립트 엔진은 코드의 문맥에 따라 동일한 함수 리터럴을 다음 중 하나로 해석한다:
    
     - 함수 리터럴을 단독으로 사용 → 함수 선언문으로 해석
    
     - 함수 리터럴이 값으로 평가되어야 하는 문맥(변수에 할당 or 피연산자로 사용) → 함수 리터럴 표현식으로 해석
    

- **함수 선언문과 함수 리터럴 표현식**
    
    둘 다 함수가 생성되는 것은 동일, 다만 함수를 생성하는 내부 동작에 차이가 있음.
    
    ```jsx
    // 함수 선언문
    function foo() { console.log("foo"); }
    foo(); // foo
    
    // 위 함수 선언문의 의사 코드
    var foo = function foo() { console.log("foo"); }
    
    // => 함수는 함수 이름으로 호출하는 것이 아니라, 함수 객체를 가리키는 식별자로 호출하는 것.
    
    // 함수 리터럴 표현식
    (function bar() { console.log("bar");  });
    // 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자 -> 함수 몸체 외부에서는 호출할 수 없음
    bar(); // ReferenceError: bar is not defined
    ```
    
- 
    
    
    | 항목 | 함수 선언문 | 함수 표현식 (리터럴) |
    | --- | --- | --- |
    | 이름 생략 가능? | ❌ 이름 필수 | ⭕ 익명 가능, 이름 있어도 내부 한정 |
    | 해석 시점 | 호이스팅 됨 | 런타임에 평가됨 |
    | 호출 가능 범위 | 선언 전/후 모두 가능 | 정의 이후만 가능, 이름은 내부에서만 참조 가능 |
    | 문 or 표현식 | 문(statement) | 표현식(expression) |

### 4-2. 함수 표현식

**함수는 일급 객체임.**

일급 객체 : 값의 성질을 갖는 객체.

➔ 함수를 값처럼 사용할 수 있음. = 변수에 할당할 수 있음 ⇒ 함수 표현식

함수 표현식 : 표현식인 문임.

```jsx
//  기명 함수 표현식
var add = function (x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7
```

### 4-3.  함수 생성 시점과 함수 호이스팅

**함수의 생성 시점**

함수 선언문 : 함수 호이스팅이 발생함.(함수 선언문이 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행됨)

함수 표현식 : 변수 호이스팅이 발생함. 함수 리터럴이 할당문이 실행되는 시점에 평가되어 함수 객체가 생성됨.

함수 호이스팅은 함수를 선언하기 전에 호출할 수 있게 하므로 함수 선언문 대신 **함수 표현식 사용을 권장**함.

### 4-4. Function 생성자 함수

**Function 생성자 함수로 함수 생성.**

```jsx
var add = new Function("x", "y", "return x + y");
```

다른 방식으로 생성한 함수와 다르게 동작하며 일반적으로 사용하지 않는다.

### 4-5. 화살표 함수(ES6)

보다 간략한 방법. 화살표 함수는 항상 익명 함수로 정의함.(26.3 화살표 함수 참고)

```jsx
var add = (x, y) => x + y;
```

---

## 5. 함수 호출

### 5-1. 매개변수와 인수

- 매개변수를 통해 인수를 전달함.
- 매개변수의 스코프(유효 범위) : 함수 내부
- 매개변수의 개수와 인수(argument)의 개수가 일치하지 않아도 됨.

### 5-2. 인수 확인

자바스크립트의 경우 함수를 정의할 때, 인수가 전달되었는지 확인할 필요가 있음.

```jsx
// 1. typeof로 인수의 타입이 부적절한 경우 에러를 발생시킴
function add(x, y) {
  if (typeof x !== "number" || typeof y !== "number") {
    throw new TypeError("인수는 모두 숫자(number)값 이어야 합니다.");
  }

  return x + y;
}
console.log(add(1, 2)); // 3
console.log(add(2)); // TypeError: 인수는 모두 숫자(number)값 이어야 합니다.
console.log(add("a", "b")); // TypeError: 인수는 모두 숫자(number)값 이어야 합니다.

// 2. 단축 평가로 매개변수에 기본값을 할당
function add(a, b, c) {
  a = a || 1;
  b = b || 1;
  c = c || 1;

  return a + b + c;
}
console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0 >>> 3(undefined > 1)
```

### 5-3. 매개변수의 최대 개수

개수가 적을수록 좋음. 3개 이하를 권장. ➔ 오류 발생과 유지보수 고려

### 5-4. 반환문

**반환문** : return 키워드 + 표현식. 생략 가능함.

```jsx
var add = function (x, y) {
  return x + y; // 반환문
};

// 함수 호출은 반환값으로 평가됨.
var result = add(2, 5)
console.log(result); // 7
```

**반환문의 역할**

 - 함수의 실행을 중단하고 함수 몸체를 빠져나감.

 - return 키워드 뒤에 오는 표현식을 평가해 반환함.

---

## 6. 참조에 의한 전달과 외부 상태의 변경

원시 타입과 객체 타입 인수를 전달 받아 함수 몸체에서 매개변수의 값을 변경할 경우. 

이때 원시 타입 인수는 값 자체를 복사하여 매개변수에 전달하기 때문에 함수 몸체에서 그 값을 변경하여도 어떠한 부수 효과(side-effect)도 발생시키지 않음.

하지만 객체형 인수는 참조값을 복사하여 매개변수에 전달하기 때문에 함수 몸체에서 그 값을 변경할 경우 원본 객체가 변경되는 부수 효과(side-effect)가 발생함. ➔ 비순수 함수

순수 함수는 외부 상태를 변경하지 않는 함수임.

- 
    
    ```jsx
    function changeVal(primitive, obj) {
      primitive += 100;
      obj.name = "Kim";
    }
    
    // 외부 상태
    var num = 100; // 원시 값
    var person = { name: "Lee" }; // 객체
    
    console.log(num); // 100
    console.log(person); // { name: 'Lee' }
    
    changeVal(num, person);
    
    console.log(num); // 100
    console.log(person); // { name: 'Kim' } 
    ```
    

---

## 7. 다양한 함수의 형태

### 7-1. 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수. 한 번만 호출됨.

 - 반드시 그룹 연산자( ... )로 감싸야 함.

 - 함수 이름이 없는 익명 함수를 사용하는 것이 일반적임.

```jsx
// 익명 즉시 실행 함수(immediately-invoked function expression)
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}());
```

### 7-2. 재귀 함수

**자기 자신을 호출하는 함수.**

자신을 무한 재귀 호출하므로 **탈출 조건**을 만들어야 함.

대부분의 재귀 함수는 for나 while 문으로 구현이 가능함. 반복문보다 재귀 함수를 통해 보다 직관적으로 이해하기 쉬운 구현이 가능한 경우에만 한정적으로 적용하는 것이 바람직함.

### 7-3. 중첩 함수

중첩 함수(내부 함수) : **함수 내부에 정의된 함수**. 중첩 함수는 외부 함수 내부에서만 호출할 수 있다.

외부 함수 : 중첩 함수를 포함하는 함수.

```jsx
function outer() {
  var x = 1;

  // 중첩 함수(내부 함수)
  function inner() {
    var y = 2;

    // 외부 함수의 변수를 참조할 수 있음.
    console.log(x + y); // 3
  }

  inner();
}

outer();
```

### 7-4. 콜백 함수

**콜백 함수** : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수.

**고차 함수** : 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수.

```jsx
// 외부에서 전달받은 f를 n만큼 반복 호출 - 고차 함수
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i); // i를 전달하면서 f를 호출
  }
}

// logAll 콜백 함수
var logAll = function (i) {
  console.log(i);
};

// 반복 호출할 함수를 인수로 전달
repeat(5, logAll); // 0 1 2 3 4

// logOdd 콜백 함수
var logOdd = function (i) {
  if (i % 2) console.log(i);
};

// 반복 호출할 함수를 인수로 전달
repeat(5, logOdd); // 1 3
```

### 7-5. 순수 함수와 비순수 함수

**순수 함수** : 어떤 외부 상태에 의존하지도 않고 변경하지도 않는 함수.

**비순수 함수** : 외부 상태에 의존하거나 외부 상태를 변경하는 함수.

비순수 함수는 코드의 복잡성을 증가시키므로 최대한 줄여 부수 효과를 억제하는 것이 좋음.
