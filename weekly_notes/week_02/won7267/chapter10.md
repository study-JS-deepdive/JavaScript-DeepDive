# 10장 객체 리터럴

## 1. 객체란?

**원시 값을 제외한 나머지 모든 값**. 원시 값과 다르게 변경 가능한 값임.

0개 이상의 **프로퍼티와 메서드로 구성**된 집합체.

상태와 동작을 하나의 단위로 구조화할 수 있어 유용함.

 **- 프로퍼티** : 객체의 상태를 나타내는 값. **키와 값**으로 구성됨. 

 **- 메서드** : 객체 안에 프로퍼티로 정의된 **함수**. 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작.

```jsx
var counter = {
	num: 0,  // 프로퍼티
  increase: function () { ... }  // 메서드
}
```

---

## 2. 객체 리터럴에 의한 객체 생성

자바스크립트는 프로토타입 기반 객체지향 언어로서 **다양한 객체 생성 방법을 지원**함.

- **객체 리터럴**
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

### **객체 리터럴**

 : 가장 일반적이고 간단함. 이 외의 방식은 모두 함수를 사용함.

 : 중괄호(**{…}**) 내에 0개 이상의 프로퍼티를 정의함.

 ➔ 여기서의 중괄호는 코드 블록을 의미하지 않음. ➔ 닫을 때에는 세미콜론(;)으로 끝맺음.

---

## 3. 프로퍼티

**객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성됨.**

프로퍼티를 나열할 때는 쉼표(,)로 구분함.

```jsx
var person = {
  name: "LEE", // 프로퍼티 키는 name, 프로퍼티 값은 "LEE"
  age: 10, // 프로퍼티 키는 age, 프로퍼티 값은 10
};
```

### **프로퍼티 키와 값으로 사용할 수 있는 값.**

프로퍼티 키 : 빈 문자열( '' ) 을 포함하는 모든 문자열 또는 심벌 값

프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값

### 프로퍼티 키와 식별자 네이밍 규칙

프로퍼티 키는 **값에 접근할 수 있는 이름**으로서 식별자 역할을 함.
식별자 네이밍 규칙(4.7장)을 준수한 이름(자바스크립트에서 사용 가능한 이름)인 경우 따옴표를 생략 가능하며, 반대의 경우 이름에 반드시 따옴표를 사용해야 함.
따라서 가급적 **식별자 네이밍 규칙을 준수하는 프로퍼티 키를 사용할 것**을 권장.

```jsx
var person = {
	firstName: 'Gildong', // 식별자 네이밍 규칙을 준수하는 프로퍼티 키
	'last-name': 'Hong',  // 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키
  last-name: 'Hong'     // 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키 -> SyntaxError: Unexpected token
};
```

### **프로퍼티 키를 동적으로 생성**하기.

 : 문자열 또는 문자열로 평가할 수 있는 표현식을 사용함.

 : 표현식을 대괄호(**[]**)로 묶어야 함.

```jsx
var obj = {};
var key = 'hello'

// ES5: 프로퍼티 키 동적 생성
obj[key] = 'world';
// ES6: 계산된 프로퍼티 이름
// var obj = {[key]: 'world'};

console.log(obj); // {hello: "world"}
```

프로퍼티 키에 **문자열이나 심벌 값 외의 값을 사용**하면 암묵적 타입 변환을 통해 **문자열**이 된다.

```jsx
// 예제 - 프로퍼티 키로 숫자 리터럴 사용 -> 따옴표는 붙지 않지만 내부적으로는 문자열로 변환됨.
var foo = {
  0: 1,
  1: 2,
  2: 3,
};

console.log(foo); // { 0: 1, 1: 2, 2: 3 }
```

### **권장하지 않는 프로퍼티 키**

- 빈 문자열(’’, “”) : 에러가 발생하지는 않지만 키로서 의미를 갖지 못함.

```jsx
var foo = {
  '': ''
};

console.log(foo); // {"": ''}
```

- 예약어(var, function …) : 에러가 발생하지 않지만 예상치 못한 에러 발생 여지가 있음.

```jsx
var foo = {
  var: '',
  function: ''
};

console.log(foo); // {var: '', function: ''}
```

- 이미 존재하는 프로퍼티 키 중복 선언
    
    : 에러가 발생하진 않지만 나중에 선언한 프로퍼티가 이전의 것을 덮어쓰므로 주의.
    

```jsx
var foo = {
  name: "Lee",
  name: "Kim",
};

console.log(foo); // { name: 'Kim' }
```

---

## 4. 메서드

자바스크립트에서 함수는 객체이므로 값으로 취급됨. ➔ 프로퍼티 값으로 함수를 사용할 수 있음.(함수:12장 참고)

**메서드** : **객체에 묶여 있는 함수**. 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라고 부름.

```jsx
var circle = {
  radius: 5, // 프로퍼티

  getDiameter: function () { // 메서드
    return 2 * this.radius; // this : circle객체 자신을 가리킴.
	  }
  };
  
  console.log(circle.getDiameter()); // 10
```

**this 키워드** : 객체 자신을 가리키는 참조변수(22장 this 참고)

---

## 5. 프로퍼티 접근

### 프로퍼티에 접근하는 방법

- **마침표 표기법**

 : 마침표 프로퍼티 접근 연산자(**.**) 사용.

 : 연산자의 좌측에는 객체로 평가되는 표현식을 기술, 우측에는 프로퍼티 키를 지정함.

 : 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름이면 사용할 수 없음.

- **대괄호 표기법**

 : 대괄호 프로퍼티 접근 연산자(**[]**} 사용. 문자열을 따옴표(’’,””)로 감싸야 함(숫자는 따옴표 생략 가능).

 : 연산자의 좌측에는 객체로 평가되는 표현식을 기술, 내부에는 프로퍼티 키를 지정함.

 : 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름일 시 사용할 수 있음.

```jsx
var person = {
  name: "Lee",
};

console.log(person.name); // Lee (마침표 표기법)
console.log(person["name"]); // Lee (대괄호 표기법)
```

```jsx
// 대괄호 프로퍼티 접근 연산자 내부의 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 함.
// 따옴표로 감싸지 않으면 자바스크립트 엔진은 식별자로 해석함.
// 숫자로 이뤄진 문자열은 따옴표 생략 가능함.
console.log(person[name]); // ReferenceError: name is not defined

// 객체에 존재하지 않는 프로퍼티에 접근 시 -> undefined가 반환됨(ReferenceError가 발생하지 않음)
console.log(person.age); // undefined
```

---

## 6. 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신됨.

```jsx
var person = {
  name: "Lee",
};

person.name = "Kim"; // person 객체에 name 프로퍼티가 존재하므로 값이 갱신됨.

console.log(person); // {name: "kim"}
```

---

## 7. 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당됨.

```jsx
var person = {
  name: "Lee",
};

// 프로퍼티 동적 생성
person.age = 10; // person 객체에 age 프로퍼티가 없으므로 동적 생성되고 값이 할당됨.

console.log(person); // { name: 'Lee', age: 10 }
```

---

## 8. 프로퍼티 삭제

**delete 연산자**

 : 객체의 프로퍼티를 삭제함.

 : 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 함. 존재하지 않는 프로퍼티를 삭제하면 에러 없이 무시됨.

```jsx
var person = {
  name: "Lee",
};

// 프로퍼티 동적 생성
person.age = 10;

// age 프로퍼티 키가 존재함
delete person.age; // age 프로퍼티 삭제
// job 프로퍼티 키는 존재하지 않음 
delete person.address; // address 프로퍼티를 삭제할 수 없음. 이때 에러가 발생하지 X

console.log(person); // { name: 'Lee'}
```

---

## 9. ES6에서 추가된 객체 리터럴의 확장 기능

### 9-1. 프로퍼티 축약 표현

프로퍼티 값으로 변수를 사용하는 경우, **변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키 생략** 가능.

이때 프로퍼티 키는 변수 이름으로 자동 생성됨.

```jsx
var x = 1, y = 2;

// ES5
var obj = {
	x: x,
	y: y
};

console.log(obj); // {x: 1, y: 2}

// ES6
const object = { x, y }; // 프로퍼티 축약 표현

console.log(object); // {x: 1, y: 2}
```

### 9-2. 계산된 프로퍼티 이름

값으로 평가되는 **표현식을 사용해 프로퍼티 키를 동적으로 생성**할 수 있음. 이를 **계산된 프로퍼티 이름**이라 함.

ES5 - **객체 리터럴 외부**에서 프로퍼티 키로 사용할 표현식을 대괄호([])로 묶어야 함.

```jsx
var prefix = "prop";
var i = 0;

var obj = {};

// <계산된 프로퍼티 이름>으로 프로퍼티 키 동적 생성
obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;

console.log(obj); // { prop-1: 1, prop-2: 2, prop-3: 3 }
```

ES6 - **객체 리터럴 내부**에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있음.

```jsx
const prefix = "prop";
let i = 0;

// <객체 리터럴 내부>에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
};

console.log(obj); // { prop-1: 1, prop-2: 2, prop-3: 3 }
```

### 9-3. 메서드 축약 표현

ES5 -  메서드 정의 시 **프로퍼티 값으로 함수를 할당**함.

```jsx
var obj = {
  name: "Lee",

  // 프로퍼티 값으로 "함수를 할당"
  sayHi: function () {
    console.log(`Hi! ${this.name}`);
  },
};

obj.sayHi(); // Hi! Lee
```

ES6 - 메서드 정의 시 **function 키워드를 생략**한 축약 표현 사용 가능.

```jsx
const obj = {
  name: "Lee",

  // 메서드 축약 표현
  sayHi() {
    console.log(`Hi! ${this.name}`);
  },
};

obj.sayHi(); // Hi! Lee
```

+) 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작함.(26.2장 메서드 참고)
