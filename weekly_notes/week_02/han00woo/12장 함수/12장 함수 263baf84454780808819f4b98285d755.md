# 12장 함수

# 12.1 함수란?

- 수학의 함수는 입력을 받아 출력을 내보내는 일련의 과정이다

![image.png](image.png)

- 프로그래밍에서 함수란 이런 일련의 과정을 문으로 정의하고 코드블록으로 감싸 하나의 실행단위로 정의한것이다.

```jsx
// 함수 정의
function add(x , y){ // x, y는 매개변수 라고 한다 
 return x + y;
}
// 함수 호출 
add(5, 3);
```

# 12.2 함수를 사용하는 이유

- 중복 코드를 제거하고 여러번 사용하는 것이 효율적이다

# 12.3 함수 리터럴

- 자바스크립트의 함수는 객체 타입의 값이다. 따라서 변수의 할당할 수 있다

```jsx
var f = function add(x , y){ // x, y는 매개변수 라고 한다 
 return x + y;
}
```

- 리터럴은 사람이 이해할 수 있는 문자나 약속된 기호를 사용해 값을 생성하는 표기 방식이다
- 함수 리터럴도 평가되어 값을 생성하며 이 값 역시 객체이다
- 함수는 일반 객체와 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.
- 일급객체를 이해하기 위해선 함수에 대해 더 잘 이해해야 한다

# 12.4 함수 정의

- 함수정의란 함수를 호출하기 이전에 다음을 지정하는것을 말한다.
    - 인수를 전달받을 매개변수
    - 실행할 문들
    - 반환값

![image.png](image%201.png)

## 12.4.1 함수 선언문

- 함수 선언문을 사용해 함수를 정의하는 방식이다

```jsx
function add(x,y){
    return x + y;
}

console.log(add);
console.log(add(2, 4));
------------------------------------------------------------
PS C:\Users\gkstj\vscode> node .\index.js
[Function: add]
6
```

- 함수 선언문은 표현식이 아닌 문이다.
- 표현식이 아닌 문은 변수에 할당할 수 없다
- 그러나 다음 코드는 변수에 할당하는것처럼 보인다

```jsx
var add = function add(x , y){ // x, y는 매개변수 라고 한다 
 return x + y;
}
console.log(add(2,5));
console.log(add);
---------------------------------
PS C:\Users\gkstj\vscode> node .\index.js
7
[Function: add]
```

- 이는 이름을 가진 함수 선언문은 리터럴로 해석될 가능성이 있음을 나타낸다

 

```jsx
//리터럴 foo는 함수 선언문으로 해석된다
function foo() {console.log('foo');}
foo();

//소괄호 내부에 있는 bar는 함수 선언문이 아닌 함수 리터럴 표현식으로 해석된다 
(function bar() {console.log('bar');});
bar();
---------------------------------------------------
PS C:\Users\gkstj\vscode> node .\index.js
foo
C:\Users\gkstj\vscode\index.js:5
bar();
^

ReferenceError: bar is not defined
```

- 이 차이는 함수를 가리키는 식별자의 유무 차이이다
- foo는 코드상에는 bar처럼 따로 대입한 식별자가 없는것처럼 보인다
- 자바스크립트 엔진이 함수 선언문의 경우 암묵적으로 생성한 식별자라 한다
- 자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성한다.
- 따라서 생성된 함수를 호출하기 위해 함수이름과 똑같은 식별자를 생성한다.
- 함수는 함수 이름이 아닌 함수 객체를 가리키는 식별자로 호출하는것이다.

![image.png](image%202.png)

![image.png](image%203.png)

## 12.4.2 함수 표현식

- 자바스크립트의 함수는 일급 객체이다
- 값처럼 자유롭게 사용할 수 있다는 의미이다

```jsx
// 함수 표현식으로 정의한 add함수 
var add = function(x, y) {
  x + y
};
console.log(add(2,5)); // 7
```

<aside>
💡

함수 리터럴의 함수 이름을 생략할 수 있는데 이를 익명함수라고 한다 

</aside>

- 함수를 호출할 때는 함수 이름이 아닌 함수를 담은 식별자를 사용해야 한다.

```jsx
// 함수 표현식으로 정의한 add함수 
var add = function foo (x, y) {
  x + y
};
console.log(add(2,5)); // 7
console.log(foo(2,5)); 
-------------------------------------------------
console.log(foo(2,5)); // foo는 함수 내부에서 선언한 이름이지 함수 식별자가 아니다
        ^

ReferenceError: foo is not defined
```

- 함수 선언문은 함수 객체에 암묵적으로 이름이 식별자로 사용되는것이다
- 함수 선언문은 ‘표현식이 아닌 문’이고 함수 표현식은 ‘표현식인 문’이다

## 12.4.3 함수 생성 시점과 호이스팅

```jsx
//함수 참조
console.dir(add);
console.dir(sub);

//함수 호출
console.log(add(2,5));
console.log(sub(2,5));

//함수 선언문 
function add(x , y){
    return x + y;
}
//함수 표현식
var sub = function (x, y){
    return x -y;
}
-------------------------------------------------------------------------------
PS C:\Users\gkstj\vscode> node .\index.js
[Function: add]
undefined
7
C:\Users\gkstj\vscode\index.js:7
console.log(sub(2,5));
            ^

TypeError: sub is not a function
```

- 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다
- 함수 선언문이 코드의 선두로 끌어올려져 동작하는 것을 함수 호이스팅이라 한다.
- 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다.
- 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생하는 것이다
- 함수 표현식으로 선언한 함수는 선언 이후에 호출해야 한다(권장)

## 12.4.4 Function 생성자 함수

- 자바스크립트가 기본적으로 제공하는 빌트인 함수 Function이 있다.
- new 연산자와 함께 필요한 값들을 전달 및 호출하면 함수 객체를 반환한다.

```jsx
var add = new Function('x','y','return x+y')
console.log(add(2,5)); //7
```

- 함수 선언문이나 함수 표현식으로 생성한 함수와 Function은 다르게 동작한다.

## 12.4.5 화살표 함수

- 화살표 함수는 익명함수로 정의한다

```jsx
const add = (x,y) => x+y;
console.log(add(2,5)); //7
```

- 생성자 함수로 사용할 수 없으며 this 바인딩 방식이 다르고 prototype 프로퍼티가 없으며 argument객체를 생성하지 않는다

# 12.5 함수 호출

- 함수는 함수 호출 연산자 () 를 사용해 0개 이상의 인수와 함께 함수를 호출한다

## 12.5.1 매개변수와 인수

- 함수 내부로 전달할 필요가 있는 값은 매개변수를 통해 인수를 전달한다

![image.png](image%204.png)

- 매개변수는 함수 몸체 내부에서만 참조가 가능하고 외부에서는 참조할 수 없다
- 함수는 매개변수와 인수의 개수가 일치하는지 체크하지 않는다
- 인수가 부족해서 할당되지 않은 매개변수의 값은 undefined 다
- 매개변수보다 초과된 인수는 무시한다
- 초과된 인수는 arguments 객체의 프로퍼티로 보관된다

## 12.5.2 인수 확인

```jsx
//함수 선언문 
function add(x , y){
    return x + y;
}

console.log(add(2,5));
console.log(add('a','b'));
----------------------------------------------------------------------------
PS C:\Users\gkstj\vscode> node .\index.js
7
ab
```

<aside>
💡

자바스크립트는 동적 타입 언어이기에 매개변수의 타입을 사전에 정의할 수 없다.

</aside>

- 따라서 자바스크립트 함수 내에서 인수를 검사하는 로직이 필요하다

```jsx
function add(x , y){
    if(typeof x !== 'number' || typeof y !== 'number'){
        throw new TypeError('인수는 모두 숫자값이어야 합니다.')
    }
    return x + y;
}
```

- 단축 평가를 사용해 매개변수에 기본값을 할당하는 방법도 있다

```jsx
function add(a, b, c){
    a = a || 0
    b = b || 0
    c = c || 0
    return a + b + c;
}
```

## 12.5.3 매개변수의 최대 개수

- 이상적인 함수는 한가지 일만 해야하며 가급적 작게 만들어야 한다.
- 이상적인 매개변수의 개수는 0개이다.

## 12.5.4 반환문

- 함수는 return 키워드와 표현식으로 이루어진 반환문을 통해 값을 외부로 전달할 수 있다.
- 반환문의 역할은 두가지가 있다
    - 함수의 실행을 종료한다
    - return 문 뒤에 오는 표현식을 평가해 반환한다
- 반환문은 생략할 수 있다
- 함수 내부에서만 사용할 수 있다

# 12.6 참조에 의한 전달과 외부 상태의 변경

- 원시값은 값을 전달하고 객체는 변경가능한 객체를 함수에 전달한다

```jsx
function changeVal(primitive, obj){
    primitive += 100;
    obj.name = "Kim";
}

var num = 100;
var person = {"name" : "lee"};

changeVal(num, person);
console.log(num);
console.log(person);
----------------------------------------------
PS C:\Users\gkstj\vscode> node .\index.js
100                //변화 x
{ name: 'Kim' }    //변화 o
```

- 객체는 함수에 전달할 경우 원본값이 변경되는 부작용이 있다
- 원본값이 변경되는것을 막기위해 옵저버 패턴, 불변객체로 변경 등의 방법이 있다
- 외부 상태를 변경하지 않고 외부 상태에 의존하지 않는 함수를 순수 함수라고 한다
- 순수함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 안정성을 높이는 패러다임을 함수형 프로그래밍이라고 한다.

# 12.7 다양한 함수의 형태

## 12.7.1 즉시 실행 함수

- 단 한번 호출되며 다시 호출할 수 없다

```jsx
// 즉시 실행 함수 (IIFE)의 기본 형태
(function () {
    console.log("즉시 실행 함수 실행됨!");
})(); // 정의하자마자 바로 실행됨

// 1. 지역 스코프를 만들어 변수 충돌 방지
(function () {
    var message = "IIFE 내부 변수";
    console.log(message); // "IIFE 내부 변수"
})();

// console.log(message); 
// 에러 발생: message is not defined (IIFE 내부에만 존재)

// 2. 매개변수를 전달해서 실행할 수도 있음
(function (name) {
    console.log("안녕하세요, " + name + "님!");
})("선우"); // 인자로 "선우" 전달

// 3. 반환값을 가질 수도 있음
var result = (function (x, y) {
    return x + y;
})(5, 7);

console.log("즉시 실행 함수의 반환값:", result); // 12

// 4. ES6 화살표 함수로도 작성 가능
(() => {
    console.log("화살표 함수로 만든 IIFE");
})();

// 5. 초기화 용도로 사용
var counter = (function () {
    var count = 0; // private 변수

    return {
        increase: function () {
            count++;
            return count;
        },
        decrease: function () {
            count--;
            return count;
        }
    };
})();

console.log(counter.increase()); // 1
console.log(counter.increase()); // 2
console.log(counter.decrease()); // 1
```

- 즉시실행 함수를 사용해서 전역변수 사용을 방지할 수 있다

## 12.7.2 재귀함수

```jsx
// 팩토리얼 계산: n! = n * (n-1) * (n-2) ... * 1
function factorial(n) {
    // 종료 조건 (무한 반복 방지)
    if (n === 1) {
        return 1;
    }
    // 자기 자신을 다시 호출 (재귀)
    return n * factorial(n - 1);
}

console.log(factorial(5)); // 120 (5*4*3*2*1)
```

## 12.7.3 중첩함수

```jsx
function outerFunction(name) {
    console.log("외부 함수 실행!");

    // 내부(중첩) 함수
    function innerFunction() {
        return "안녕하세요, " + name + "님!";
    }

    // 중첩 함수 호출
    return innerFunction();
}

console.log(outerFunction("선우")); 
// 출력: 외부 함수 실행!
// 출력: 안녕하세요, 선우님!
```

## 12.7.4 콜백 함수

- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라 한다
- 매개변수를 통해 다른 함수를 들여오는 함수를 고차함수라 한다.
- 고차함수는 콜백함수를 자신의 일부분으로 합성한다
- 콜백함수는 고차함수에 의해 호출되며 필요에 따라 콜백함수를 인수에 전달할 수 있다

```jsx
function refeat(n,f) {
    for(var i =0;i<n;i++){
        f(i);
    }
}

var logAll = function(i){
    console.log(i);
}

refeat(5,logAll);
```

## 12.7.5 순수함수와 비순수함수

 

## ✅ 순수 함수 (Pure Function)

- 같은 입력 → 항상 같은 출력
- 외부 상태를 변경하지 않음 (부작용 없음)
- 외부 변수를 참조하더라도 변경하지 않음

```jsx
// 순수 함수 예제
function add(a, b) {
    return a + b; // 입력 값에만 의존 → 항상 같은 결과
}

console.log(add(2, 3)); // 5
console.log(add(2, 3)); // 5 (항상 동일)

// 또 다른 순수 함수 예제
function square(x) {
    return x * x;
}

console.log(square(4)); // 16
console.log(square(4)); // 16 (동일 입력은 동일 출력)

```

📌 특징:

- 테스트가 쉽고 디버깅이 편리
- 병렬 처리나 함수형 프로그래밍에 유리

---

## ✅ 비순수 함수 (Impure Function)

- 같은 입력이어도 결과가 달라질 수 있음
- 외부 상태를 변경하거나, 외부 환경(날짜, 랜덤 값 등)에 의존
- 부작용(side effect)이 발생

```jsx
let count = 0;

// 비순수 함수 예제 1: 외부 변수 변경
function increase() {
    count++; // 외부 상태 변경 (부작용)
    return count;
}

console.log(increase()); // 1
console.log(increase()); // 2 (같은 입력인데 다른 출력)

// 비순수 함수 예제 2: 현재 시간 사용
function getCurrentTime() {
    return new Date().toLocaleTimeString();
}

console.log(getCurrentTime()); // 실행할 때마다 다른 값

// 비순수 함수 예제 3: 랜덤 값 반환
function getRandom() {
    return Math.random();
}

console.log(getRandom()); // 호출할 때마다 달라짐

```

📌 특징:

- 실행 시점마다 결과가 달라질 수 있음
- 외부 세계(파일, DB, 네트워크, UI 등)와 상호작용할 때는 불가피하게 필요