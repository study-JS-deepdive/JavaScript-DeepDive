# 4장 변수

## 변수의 필요성


```jsx
10 + 20
```

- 자바스크립트 엔진은 위 자바스크립트 코드를 **계산(평가)**하기 위해
- 10, +, 20 이라는 **리터럴(기호)**를 파악하고 `10 + 20` 이라는 **표현식(식)**를 해석
- **파싱**

위의 매커니즘을 통해 30이라는 값을 계산해낼 수 있으며 이를 아래와 같이 메모리 구조로 나타낼 수 있음

<img width="362" height="381" alt="image" src="https://github.com/user-attachments/assets/643913b0-884b-45a4-a67f-8d2b0406c66e" />


자바스크립트 엔진은 `10 + 20` 을 계산하기 위해 10, 20을 CPU의 메모리에 저장하여 + 연산을 진행함

<img width="344" height="348" alt="image" src="https://github.com/user-attachments/assets/0e21e3e7-7232-4fd4-9c80-15670342a875" />


연산 결과 값인 `30` 이라는 값도 메모리에 임의로 저장됨

여기서 한가지 알아야 할 점은 CPU에서 연산한 30이란 값을 `재사용 할 수 없음` 

만약 값을 재사용하려면 값이 저장된 **메모리에 직접 접근해야 하는데 이는 치명적 오류를 발생시킬 가능성이 매우 높으므로 자바스크립트는 개발자의 직접적인 메모리 제어를 기본적으로 허용하지 않음**

만약 메모리 제어를 허용하더라도 문제가 있는데, 위의 그림에서 10, 20이 저장된 메모리 주소는 고정적으로 정해져 있지 않으므로 코드가 실행될 때마다 주소가 변경되며, 그 주소를 알 수도 없고 알려주지도 않음. 따라서 메모리에 직접 접근하는 방법은 효율성도 떨어지고 리스크가 큼

**그래서 저장된 값을 재사용하기 위해 변수라는 메커니즘을 사용해야 함**

## 4. 1 변수란?


하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 뜻함

> ***값을 저장하고 참조하는 메커니즘에 의해 값의 위치를 가리키는 상징적인 이름***
> 

변수를 사용함으로써 개발자가 직접 메모리 주소에 접근할 필요 없이 변수를 통해 안전하게 접근이 가능함

<aside>


### 변수에 여러 개 값을 저장하는 방법

기본적으로 변수는 하나의 값을 저장하기 위한 매커니즘임 여러 개의 값을 저장하려면 여러개의 변수를 사용해야 하는데 배열 또는 객체같은 자료구조를 사용하면 여러개의 값을 하나의 값처럼 사용할 수 있음

```jsx
// 변수는 하나의 값을 저장할 수 있음
let userId = 1;
let userName = 'Lee';

// 객체 또는 배열을 사용하여 여러개의 값을 하나의 값처럼 사용 가능
const user = { id: 1, name: 'Lee' }; // 객체
const users = [
	{ id: 1, name: 'Lee' },
	{ id: 2, name: 'Hwang' },
]; // 배열
```

</aside>

앞서 `10 + 20`을 변수를 사용하여 코드를 작성해보면 

```jsx
const result = 10 + 20;
```

![image.png](4%EC%9E%A5%20%EB%B3%80%EC%88%98%2025cbaf844547807287f6c1755ee3ebd2/image%202.png)

`10 + 20` 연산을 통해 30을 생성하여 메모리에 저장된다. 이 때, 30이 저장된 메모리(0x0669F913)에 직접 접근은 불가하므로 이 위치를 가리키고 참조할 수 있는 `result` 라는 변수를 선언하여 30이라는 값을 재사용 할 수 있게 됨

### 변수 요약

- 변수란? **메모리에 저장된 값을 식별할 수 있는 고유한** **이름(예제의 result)을 변수 이름 또는 변수명이라 함**
- 변수에 저장된 값(예제의 30)을 **변수 값**이라고 함
- 변수에 값을 저장하는것을 **할당**이라 하고, 변수에 저장된 값을 읽어 들이는것을 **참조**라고 함

### 변수 사용 시 주의 사항

변수는 결국 사람이 메모리에 접근하기 위한 메커니즘이다. 그러므로 변수명을 사용할 땐 사람이 이해 할 수 있어야 하며 변수에 저장된 값의 의미를 파악할 수있는 변수명을 사용해야 코드를 파악하기 좋고 가독성이 높아짐

## 4.2 식별자


변수명을 식별자라고도 함

> ***식별자는 어떤 값을 구별해서 식별 할 수 있는 고유한 이름을 뜻함***
> 

식별자는 메모리 공간에 저장되어 있는 어떠한 값을 구별해서 식별할 수 있어야 함

따라서 식별자는 값이 저장되어 있는 메모리 공간의 **주소**를 기억(저장) 해야 함

위의 예제에서 식별자 result는 값 30을 식별 할 수 있었는데, 식별할 때 메모리 공간에 들어있는 값을 식별한것이 아닌 메모리 주소(위 예제에서는 0x0669F913)를 기억함.

즉, **식별자는 값이 아니라 메모리 주소를 기억하고 있음. 이를 해석하면 식별자는 값이 저장된 메모리의 주소를 통해 메모리 공간에 저장된 값을 접근할 수 있다는것을 의미함.**

식별자는 변수명에만 사용되지 않음 변수, 함수, 클래스 등의 이름은 모두 식별자이며 이러한 식별자는 네이밍 규칙을 준수하여 **선언**에 의해 자바스크립트에 식별자의 존재를 알릴 수 있음

## 4.3 변수 선언

변수 선언이란? 변수를 생성하는것

변수를 사용하려면 반드시 **선언**을 해야함

### 변수 선언 키워드

- var
- let
- const

`let`, `const` 키워드가 도입되기 전 까지 `var` 가 유일한 변수 선언 키워드였음

<aside>


**키워드**

키워드는 자바스크립트 코드를 해석하고 실행하는 일종의 명령어. 자바스크립트 엔진이 키워드를 만나면 약속된 동작을 수행함 → var 키워드를 만나면 그 뒤에 오는 변수명으로 새로운 변수를 선언함

</aside>

**변수 선언 과정**

- 선언 단계: 위 예제처럼 키워드 뒤에 변수명을 붙혀 변수를 선언했음을 명시
- 초기화 단계: 초기 값을 할당하는 단계, 위 예제의 경우 특정 값을 할당하지 않았으므로 undefined가 암묵적으로 할당되어 초기화 됨

```jsx
var score; // 변수 선언
```

위 소스코드에 변수 선언을 했으나 값이 할당되지 않았음

이 경우 일반적으로 변수 선언에 따른 확보된 메모리 공간이 비어 있을거라 생각 할 수 있지만 자바스크립트는 선언된 변수에 값이 할당되지 않을 경우 `undefined` 값이 암묵적으로 할당되어 초기화 됨. 

**초기화 과정을 거치지 않을 경우** 확보한 메모리 공간에 이전에 사용했던 값이 남아 있을 수 있는데, **자바스크립트는 변수 선언과 동시에 초기화를 진행하므로 이러한 문제로부터 안전함**

<aside>


**변수명은 어디에 등록될까?**

변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록 됨

변수명과 값은 실행 컨텍스트 내 키(key)/값(value) 형식은 객체로 등록되어 관리

</aside>

## 4.4 변수 선언의 실행 시점 및 변수 호이스팅


### 변수 선언의 실행 시점

```jsx
console.log(score); // undefined

var score; // 변수 선언문
```

- 자바스크립트는 소스코드 한줄 씩 처리하는 인터프리터 언어
- 변수 선언을 포함한 모든 선언문은 소스코드를 실행하기 전(Runtime 전) 소스 평가 과정에서 먼저 실행됨
- 소스 평가 과정이 끝나면 그 외에 소스코드들이 실행됨
- 선언문이 소스코드 내 어디에 있더라도 항상 먼저 실행됨

### 호이스팅

위 예제에서 console.log(score)보다 변수 선언문이 마치 위로 끌어 올려진것처럼 동작하는것을 변수 호이스팅이라함

## 4.5 값의 할당


변수에 값을 할당 하는 방법은 `=` 연산자를 사용함 → 우변의 값을 좌변의 변수에 할당

```jsx
var score; // 변수 선언
score = 80; // 값 할당
```

변수 선언과 값 할당을 한번에 할 수도 있음

```jsx
var score = 80;
```

**변수 선언과 값의 할당은 실행 시점이 다름**

- 변수 선언은 런타임 시전 이전에 실행됨(소스 평가 과정)
- 값의 할당은 런타임 시점에 실행됨

```jsx
console.log(score); // undefined

var score; 1️⃣
score = 80; 2️⃣

console.log(score); // 80
```

- 1️⃣은 소스코드가 런타임 하기 전 변수 선언과 초기화(undefined)가 진행됨
- 2️⃣에서 선언이 완료된 변수(score)에 값(80)을 할당(값이 undefined → 80으로 재할당)
- score를 출력하면 80이 출력됨

<aside>


**변수에 값을 재할당 할 때는 undefined가 저장되어 있던 메모리 공간을 지우고 해당 메모리 공간에 80일 재할당하는것이 아니라 새로운 메모리 공간에 값을 할당하여 저장함**

</aside>

## 4.6 값의 재할당


```jsx
var score = 80; // 변수 선언 및 값의 할당
score = 90; // 값의 재할당
```

- 변수: 재할당을 통해 값이 변경되는 수
- 상수: 재할당을 통해 값이 변경되지 않는 수
- 변수에 값을 재할당하게 되면 기존 메모리 공간의 값을 제거하고 재할당된 값이 저장되는것이 아니라 새로운 메모리 공간을 확보하여 90이란 값을 저장함

## 4.7 식별자 네이밍 규칙


식별자를 생성할 땐 아래와 같은 규칙을 준수해야함

- 특수문자를 제외한 문자, 숫자 언더스코어(_), 달러 기호($) 사용 가능
- 단, 특수문자를 제외한 문자, 언더스코어, 달러기호로 시작해야 하며 숫자로 시작하는것으 허용하지 않음
- 예약어 사용 불가
- 한글 및 일본어등 유니코드 문자도 사용 가능하나 권장하지 않음

### 네이밍 컨벤션

하나 이상의 영어단어로 구성되 식별자를 생성할 때 가독성을 좋게 하기 위한 규칙

```jsx
// 카멜케이스
var firstName;

// 스네이크 케이스
var first_name;

// 파스칼 케이스
var FirstName;
```

일관성을 유지한다면 어떤 컨벤션을 사용하든 문제되지 않지만 자바스크립트에서 일반적으로 변수나 함수의 이름은 카멜케이스를 사용하고 생성자 함수, 클래스 이름에는 파스칼 케이스를 사용함
