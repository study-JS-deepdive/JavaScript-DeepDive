### 4장 변수

---

- 리터럴, 연산자 조합 → 표현식을 파싱(해석)
- 리터럴: 프로그래머가 직접 적어 넣은 값
- 연산자(+, x, ), 피연산자(10, 20)

---

- `10 + 20`을 해서 `30`이 나와도 메모리 공간에 주소로 저장될 뿐 (직접 메모리 주소로 접근해선 안 된다)
- 재사용하기 위해 *변수* 사용

### **변수**

: 값의 위치를 가리키는 상징적인 이름

(값을 저장하기 위해 확보된 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름)

→ 컴파일러 혹은 인터프리터가 변수를 메모리 공간의 주소로 매칭하여 실행

```jsx
var userId = 1;

// 한 변수에 여러 값 넣고 싶다면, 그룹화(객체, 배열)
var users = [
  { id: 0, name: 'Jeong'},
  { id: 1, name: 'Kang'}.
];
```

- var result = 10 + 20;
    - → 30을 메모리 공간에 저장. 이 메모리 공간의 상징적 이름이 result 변수
    - → result에 30을 할당
    - → result 값 읽어들이기: 참조
- 여기서 메모리는
    - 백엔드라면 서버의 메모리
    - 프론트엔드(브라우저)라면 사용자 각각의 컴퓨터 메모리

---

### **식별자**

- 구별해서 식별할 수 있는 고유한 이름 (변수, 함수, 클래스 등)
- 식별자는 메모리 주소를 기억
- 네이밍 규칙을 지켜야 함

---

### **변수 선언**

- 메모리 공간 확보, 메모리 주소 연결, 값 저장
- "var", "let", "const" → 변수 선언 키워드
- var는 현재 안 쓰는 게 좋다 (ES5 이전 버전으로 작성된 코드도 현재 버전에서 정상 작동)
- var score; → 값을 안 주면 'undefined'로 초기화
- 자바스크립트 엔진의 실행 컨텍스트에 **키/값 (변수이름/변수값)**으로 등록, 관리

---

### **선언 시점과 호이스팅**

```jsx
console.log(score); // -> error 아니고 undefined !

var score;
```

- 인터프리터 언어기 때문에 순차적으로 한 줄씩 실행하지만,
- 런타임 시점 이전 단계(코드 평가과정)에서 변수 선언들을 먼저 한다 → undefined로 초기화
- 선언문이 코드의 선두로 끌어올려지는 것처럼 동작 = **호이스팅**

### 할당

선언한 변수에 값을 넣는 것

```jsx
console.log(results);

results = 30; 
var results; // 이 경우에도 선언 먼저 위로 호이스팅됨

console.log(results);
```

### **재할당**

- 변수, 상수(재할당 불가)
- 재할당으로 인해 쓸모 없어진 값은 **가비지 콜렉터**가 메모리 해제

---

### **식별자 네이밍 규칙**

- 예약어 제외 (await, this, if, for 등 이미 정해진 것)
- 문자, 숫자, 언더스코어 _, 달러 기호 $ 사용 가능
- 숫자로 시작할 수 없음
- 대소문자 구별함
- **의미하는 바가 드러나도록**

→ 카멜: 변수, 함수 이름
→ 파스칼: 생성자 함수, 클래스 이름
