### 07장 연산자

## 1. 산술 연산자

피연산자를 대상으로 수학적 계산을 수행해 새 숫자 값을 만듦.

산술 연산이 불가능한 경우 NaN을 반환함.

피연산자의 개수에 따라 구분 : 이항 산술 연산자 / 단항 산술 연산자

### 1-1. 이항 산술 연산자

2개의 피연산자를 산술 연산하여 새로운 숫자 값을 만듦.

피연산자의 값을 변경하는 부수 효과가 없어 언제나 새 값을 만든다.

| 이항 산술 연산자 | 의미 | 부수 효과 |
| --- | --- | --- |
| + | 덧셈 | X |
| - | 뺄셈 | X |
| * | 곱셈 | X |
| ? | 나눗셈 | X |
| % | % | X |

```jsx
// **이항 산술 연산자**

5 + 2; // 7
5 - 2; // 3
5 * 2; // 10
5 / 2; // 2.5
5 % 2; // 1
```

### 1-2. 단항 산술 연산자

1개의 피연산자를 산술 연산하여 숫자 값을 만듦.

| 단항 산술 연산자 | 의미 | 부수 효과 |
| --- | --- | --- |
| ++ | 1씩 증가 | O |
| -- | 1씩 감소 | O |
| + | 어떠한 효과도 없음.
음수를 양수로 반전하지도 않음. | X |
| - | 양수를 음수로, 음수를 양수로 반전한 값을 반환함. | X |

```jsx
// 단항 산술 연산자

var x = 2;

x++; // x = x + 1;
console.log(x); // 3

x--; // x = x - 1;
console.log(x); // 2
```

**증가/감소(++/—) 연산자**

증가/감소(++/—) 연산자는 피연산자의 값을 변경하는 부수 효과가 있음. 따라서 증가/감소 연산을 하면 피연산자의 값을 변경하는 함묵적 할당이 이뤄짐.

**증가/감소(++/—) 연산자의 위치**

- 전위 증가/감소 연산자(++x, --x)
    
    : 피연산자 앞에 위치. 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행.
    
- 후위 증가/감소 연산자(x++, x--)
    
    : 피연산자 뒤에 위치. 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킴.
    

```jsx
// 전위 연산자
let x = 5;
console.log(++x);  // 출력: 6
console.log(x);    // 출력: 6

// 후위 연산자
let x = 5;
console.log(x++);  // 출력: 5  (먼저 현재 값을 출력)
console.log(x);    // 출력: 6  (그 다음에 값이 증가)
```

```jsx
// 전위/후위 연산자

var x = 5, result;

// 선할당 후증가
result = x++;
console.log(result, x);      // 5 6

// 선증가 후할당
result = ++x;
console.log(result, x);      // 7 7

// 선할당 후감소
result = x--;
console.log(result, x);      // 7 6

// 선감소 후할당
result = --x;
console.log(result, x);      // 5 5
```

**+ 단항 연산자**

숫자 타입 피연산자에 어떠한 효과도 없음.

숫자 타입이 아닌 피연산자에 사용하면 **숫자 타입으로 변환**하여 반환함. 이때 피연산자를 변경하는게 아니라 변환한 값을 생성해서 반환함. 따라서 부수 효과는 없음.

숫자 타입으로 **변환 불가 시 NaN**을 반환함.

```jsx
// + 단항 연산자

var x = '1';

console.log(+x); // 1
console.log(x); // "1"

x = 'hello';
console.log(+x); // NaN
console.log(x); // "hello"
```

 **- 단항 연산자**

피연산자의 **부호를 반전**한 값을 반환함.

숫자 타입이 아닌 피연산자에 사용하면 **숫자 타입으로 변환**하여 반환함. 이때 피연산자를 변경하는게 아니라 부호를 반전한 값을 생성해 반환함. 따라서 부수 효과는 없음.

숫자 타입으로 **변환 불가 시 NaN**을 반환함.

```jsx
// - 단항 연산자

-(-10); // 10

-'10'; // -10

-true; // -1

-'Hello'; // NaN
```

### 1-3. 문자열 연결 연산자

+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 **문자열 연결 연산자로 동작**함.

그 외의 경우는 산술 연산자로 동작함.

```jsx

// number + number > 산술 연산자
1 + 2; // 3

// 아래부터는 암묵적 타입 변환(**타입 강제 변환)**이 일어남.

// number + string > 문자열 연결 연산자
'1' + 2; // '12'
1 + '2'; // '12'

// boolean + number > true는 1로, false는 0으로 타입 변환 후 산술 연산
1 + true; // 2
1 + false; // 1

// number + null > 0으로 타입 변환 후 산술 연산
1 + null; // 1

// number + undefined > undefined는 숫자로 타입 변환되지 않음.
+undefined; // NaN
1 + undefined; // NaN
```

**→ 암묵적 타입 변환(타입 강제 변환)**

    : 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변환되는 것.

---

## 2. 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당함.

변수 값이 변하는 부수 효과가 있음.

| 할당 연산자 | 예시 | 동일 표현 | 부수 효과 |
| --- | --- | --- | --- |
| = | x = 5 | x = 5 | O |
| += | x += 5 | x = x + 5 | O |
| -= | x -= 5 | x = x - 5 | O |
| *= | x *= 5 | x = x * 5 | O |
| /= | x /= 5 | x = x / 5 | O |
| %= | x %= 5 | x = x % 5 | O |

---

## 3. 비교 연산자

좌항과 우항의 피연산자를 비교하고 그 결과를 불리언 값으로 반환함.

==, ===, !=, !==

### 3-1. 동등/일치 비교 연산자

**동등 비교 연산자**

비교하려는 두 피연산자가 **서로 다른 타입이면 암묵적 타입 변환으로 타입을 일치시킨 후 비교**함.

타입 강제 변환 때문에 결과를 예측하기 어렵고 실수하기 쉬우므로 권장하지 않음.

```jsx
5 == "5";      // true  (문자열 "5"가 숫자 5로 변환됨)
0 == false;    // true  (false가 0으로 변환됨)
null == undefined;  // true 

```

**일치 비교 연산자**

비교하려는 두 피연산자의 타입과 값 모두 일치해야 true를 반환함.

암묵적 타입 변환(타입 강제 변환)을 하지 않음.

```jsx
5 === 5;        // true
5 === "5";      // false (타입 다름)
0 === false;    // false (타입 다름)
null === undefined;  // false (타입 다름)
```

**NaN**

NaN은 자신과 일치하지 않는 유일한 값임.

숫자가 NaN인지 조사하려면 빌트인 함수 **Number.isNaN**을 사용

```jsx
NaN === NaN; // false

// Number.isNaN(value)함수 : NaN인지 확인하고 그 결과를 불리언 값으로 반환함.
Number.isNaN(NaN); // true
Number.isNaN(10); // false
Number.isNaN(1 + undefined); // true (1 + undefined 결과는 NaN 이기 때문)
```

**숫자 0**

자바스크립트에는 양의 0과 음의 0이 있음. 이들을 비교하면 true를 반환함.

```jsx
// 양의 0과 음의 0의 비교, 일치 비교/동등 비교 모두 결과는 true임.
0 === -0; // true
0 == -0; // true
```

**Object.is 메서드**

ES6에서 도입된 Object.is 메서드는 **예측 가능한 정확한 비교 결과를 반환**함.

그 외에는 일치 비교 연산자(===)와 동일하게 동작함.

```jsx
+0 === -0; // true
Object.is(-0, +0); // false

NaN === NaN; // false
Object.is(NaN, NaN); // true
```

**부동등/불일치 비교 연산자**

동등 비교 연산자와 일치 비교 연산자의 반대 개념.

!= : 느슨한 부등 비교 (타입 변환 있음)

!== : 엄격한 부등 비교 (타입 변환 없음)

```jsx
5 != "5";   // false
5 !== "5";  // true
```

### 3-2. 대소 관계 비교 연산자

피연산자의 크기를 비교하여 불리언 값을 반환함.

>, <, >=, <=

---

## 4. 삼항 조건 연산자

조건식의 평가 결과에 따라 반환할 값을 결정.

부수 효과 없음.

<aside>

조건식 ? 조건식이 참일 때 반활할 값 : 조건식이 거짓일 때 반환할 값

</aside>

삼항 조건 연산자 표현식은 값처럼 사용할 수 있음.

비슷한 if문은 표현식이 아닌 문이므로 값처럼 사용할 수 없음.

조건에 따라 어떤 값을 결정해야 한다면, 삼항 조건 연산자 표현식을 사용하는 편이 유리.

조건에 따라 수행해야 할 문이 하나가 아니라 여러개라면, if ~ else 문의 가독성이 더 좋음.

---

## 5. 논리 연산자

피연산자를 논리 연산함.

| 논리 연산자 | 의미 | 부수 효과 |
| --- | --- | --- |
| || | 논리합(OR) | X |
| && | 논리곱(AND) | X |
| ! | 부정(NOT) | X |

논리합(||), 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있음.(9장의 단축 평가 참고)

논리 부정(!) 연산자는 언제나 불리언 값을 반환함.

---

## 6. 쉼표 연산자

---

## 7. 그룹 연산자

---

## 8. typeof 연산자

피연산자의 데이터 타입을 문자열로 반환함.

null 을 반환하는 경우는 없음.

```jsx

typeof ""; // "string"
typeof 1; // "number"
typeof NaN; // "number"
typeof true; // "boolean"
typeof undefined; // "undefined"
typeof Symbol(); // "symbol"
typeof null; // "object"
typeof []; // "object"
typeof {}; // "object"
typeof new Date(); // "object"
typeof /test/gi; // "object"
typeof function () {}; // "function"
```

null 타입인지 확인할 때는 "일치 연산자(===)" 를 사용하기.

```jsx
var foo = null;

typeof foo === null; // false
foo === null; // true
```

선언하지 않은 식별자를 typeof로 연산하면, ReferenceError가 아닌 undefined 를 반환함.

```jsx
// undeclared 변수를 선언한 적이 없음.
typeof undeclared; // undefined
```

---

## 9. 지수 연산자

거듭 제곱하여 숫자 값을 반환. ** 사용.

---

## 10. 그 외의 연산자

| **연산자** | **개요** | 참고 |
| --- | --- | --- |
| ?. | 옵셔널 체이닝 연산자 |  |
| ?? | null 병합 연산자 |  |
| delete | 프로퍼티 삭제 |  |
| new | 생성자 함수를 호출할 때 사용하여 인스턴스를 생성 |  |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 |  |
| in | 프로퍼티 존재 확인 |  |

---

## 11. 연산자의 부수 효과

=, ++, --, delete연산자는 부수 효과가 있음.

---

## 12. 연산자 우선순위

종류가 많아 기억하기 어렵고 실수하기 쉬우므로 그룹 연산자(**()**) 사용을 권장.

---

## 13. 연산자 결합 효과

연산자의 어느 쪽(좌항/우항)부터 평가할 것인지를 나타냄.
